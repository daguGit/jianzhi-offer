package com.github.dagugit.algorithm;

/**
 * 数组中的逆序对
 * <p>
 * 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。
 * 并将P对1000000007取模的结果输出。 即输出P%1000000007
 * 输入描述:
 * 题目保证输入的数组中没有的相同的数字
 * 数据范围：
 * 对于%50的数据,size<=10^4
 * 对于%75的数据,size<=10^5
 * 对于%100的数据,size<=2*10^5
 * <p>
 * 示例1
 * 输入
 * 1,2,3,4,5,6,7,0
 * 输出
 * 7
 */
public class _35_InversePairs {
    /**
     * 思路1：
     * 使用纯暴力的解法
     * 1、双层for循环
     * <p>
     * 思路2：
     * 之前的思路，时间复杂度 O(n2)
     * 归并排序的思路 -----------借鉴他人思路
     * 1、归并过程中需要改变数组元素位置，所以需要另拷贝一个数组
     * 2、归并逆序对，等于 左半部分逆序对+右半部分逆序对+合并过程的逆序对
     * 3、左右部分逆序对分别使用递归
     * 4、合并过程逆序对：另 i=mid,j=end
     * -A:  if(array[i]>array[j]) count+=右半部分数量
     * -B：else 另 j--；
     * -C:将未归并的归并到数组中
     *
     * @param array
     * @return
     */
    public int InversePairs(int[] array) {
        int count = 0;
        for (int i = 0; i < array.length; i++) {
            for (int j = i + 1; j < array.length; j++) {
                if (array[i] > array[j]) {
                    count++;
                }
            }
        }
        return count % 1000000007;
    }

    public static void main(String[] args) {
        _35_InversePairs inversePairs = new _35_InversePairs();
//        int[] array = {1,4,2,3,5,6,7,0};
        int[] array = {627126, 415347, 850134, 371085, 279048, 705820, 453064, 944751, 92317, 58592, 167988, 284065, 992573, 78043,
                190215, 104546, 607528, 391775, 701214, 849731, 231053, 603058, 975374, 199773, 479544, 143961, 206797, 325662, 90035,
                69615, 429916, 717161, 484962, 796403, 604598, 280362, 502223, 57662, 741466, 594540, 632606, 909454, 394957, 625180,
                503849, 585172, 729726, 627729, 976947, 947293, 477461, 724352, 66703, 452835, 440478, 62599, 596797, 163627, 388261,
                203184, 233243, 334529, 436697, 234557, 647284, 41295, 514920, 665859, 615310, 256386, 776752, 247916, 682192, 171709,
                389448, 186041, 273234, 635527, 813771, 766533, 582820, 807584, 490886, 649523, 260419, 447716, 228474, 373568, 611343,
                616735, 576752, 844586, 467616, 529801, 595496, 631253, 571097, 110416, 297112, 186407, 883154, 73864, 950675, 81698,
                245574, 340124, 267739, 35160, 975651, 597862, 801693, 74823, 921798, 292579, 240698, 182218, 256647, 469172, 72138,
                867991, 602259, 165243, 228929, 69875, 695044, 824425, 701128, 782493, 451193, 998241, 485252, 334347, 588457, 435928,
                416045, 350383, 292404, 200137, 385543, 268055, 314351, 187237, 859230, 236150, 996168, 99928, 934720, 252816, 569100,
                523210, 120807, 171359, 688453, 866088, 757586, 383498, 206866, 458715, 682343, 658059, 973308, 167596, 508759, 78117,
                603524, 441156, 428501, 412280, 157645, 814044, 196687, 471997, 1281, 55917, 224499, 997450, 155845, 159219, 250266,
                241297, 682429, 887425, 412656, 887235, 269865, 686594, 787085, 476731, 661661, 469428, 134791, 634969, 637024, 643550,
                229439, 756900, 601058, 657940, 169180, 758704, 471984, 365867, 230701, 473266, 421784, 455200, 470716, 93981, 130771,
                237334, 335278, 329552, 641111, 264286, 733139, 910976, 950881, 520224, 904060, 612542, 989653, 38851, 763864, 143029,
                198753, 993303, 899930, 799811, 651243, 585462, 558515, 639579, 951330, 305568, 112845, 889466, 277120, 99913, 499800,
                924243, 853599, 835078, 770148, 11062, 615717, 503287, 922039, 82950, 23512, 826099, 695492, 529517, 381302, 975708,
                672546, 96407, 485363, 88828, 896218, 652958, 674291, 971086, 292538, 141973, 276654, 921735, 547791, 70127, 21649,
                47591, 994370, 391600, 399022, 764518, 402663, 14739, 267806, 841054, 97689, 807670, 183505, 309533, 337187, 564807,
                801594, 9733, 661214, 803309, 614914, 73784, 456268, 805557, 44870, 265158, 947530, 837877, 703245, 11673, 908004,
                241246, 59265, 418726, 632847, 974639, 183245, 35510, 505730, 967403, 392916, 603419, 775073, 576421, 429304, 112260,
                141228, 747250, 638345, 318794, 550560, 769611, 392578, 523180, 575168, 953801, 304690, 39050, 308030, 7935, 50724,
                216034, 249182, 626341, 151112, 882029, 600980, 334357, 433891, 106710, 818112, 826807, 226481, 593185, 919580,
                172137, 221797, 60808, 919388, 376495, 895954, 986300, 146106, 804884, 509480, 237627, 275037, 814170, 276677,
                583067, 338457, 327401, 315453, 587639, 953742, 466566, 986020, 71074, 317275, 936263, 694136, 135388, 763070,
                920617, 728573, 682650, 92755, 466723, 259810, 528495, 843218, 672116, 514795, 505676, 477001, 24275, 259655,
                752038, 354797, 536333, 335106, 693254, 380086, 166911, 797246, 850181, 633477, 783266, 921255, 950753, 719530,
                615392, 86141, 998952, 52361, 331066, 197955, 661468, 797789, 974117, 189963, 157359, 646234, 704758, 179388,
                639587, 245385, 439043, 907977, 116534, 491728, 759435, 809789, 871815, 926347, 123387, 721996, 559824, 423005,
                159603, 510577, 142535, 774995, 113070, 657840, 343709, 444137, 372147, 5177, 758278, 346264, 195141, 915638, 508850,
                416251, 611378, 664789, 661637, 50421, 572767, 294523, 58502, 332202, 620664, 930317, 258549, 744051, 652313, 818374,
                167057, 811916, 845303, 825944, 103264, 474726, 483784, 446973, 918863, 855931, 968502, 677141, 718548, 163643, 109131,
                743750, 96247, 720509, 408540, 274236, 287283, 981307, 568759, 862137, 313509, 189424, 792454, 88411, 933475, 961119,
                423137, 616884, 773035, 268440, 442829, 392651, 743166, 442965, 839624, 178381, 815249, 324479, 371875, 533797, 488122};
        int i = inversePairs.InversePairs_MergeSort(array);
        System.out.println(i);
    }

    /**
     * 之前的思路，时间复杂度 O(n2)
     * 归并排序的思路 -----------借鉴他人思路
     * 1、归并过程中需要改变数组元素位置，所以需要另拷贝一个数组
     * 2、归并逆序对，等于 左半部分逆序对+右半部分逆序对+合并过程的逆序对
     * 3、左右部分逆序对分别使用递归
     * 4、合并过程逆序对：另 i=mid,j=end
     * -A:  if(array[i]>array[j]) count+=右半部分数量
     * -B：else 另 j--；
     * -C:将未归并的归并到数组中
     *
     * @param array
     * @return
     */
    public int InversePairs_MergeSort(int[] array) {
        if (array == null || array.length <= 1) {
            return 0;
        }
        int[] copy = new int[array.length];
        for (int i = 0; i < array.length; i++) {
            copy[i] = array[i];
        }
        return mergeCount(array, copy, 0, array.length - 1);
    }

    public static int mergeCount(int[] array, int[] copy, int start, int end) {
        if (start == end) {
            copy[start] = array[start];
            return 0;
        }
        int mid = (start + end) >> 1;
        int leftCount = mergeCount(copy, array, start, mid);
        int rightCount = mergeCount(copy, array, mid + 1, end);
        //i初始化为前半段最后一个数字的下标
        int i = mid;
        //j初始化为后半段最后一个数字的下标
        int j = end;
        //辅助数组复制的数组的最后一个数字的下标
        int index = end;
        //计数--逆序对的数目
        int count = 0;
        // 统计合并数组逆序对
        while (i >= start && j >= mid + 1) {
            if (array[i] > array[j]) {
                copy[index--] = array[i--];
                count += j - mid;
                if (count >= 1000000007)//数值过大求余
                {
                    count %= 1000000007;
                }
            } else {
                copy[index--] = array[j--];
            }
        }
        for (; i >= start; i--) {
            copy[index--] = array[i];
        }
        for (; j >= mid + 1; j--) {
            copy[index--] = array[j];
        }
        return leftCount + rightCount + count % 1000000007;
    }
}
