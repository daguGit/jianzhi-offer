package com.github.dagugit.algorithm;


/**
 * 整数中1出现的次数（从1到n整数中1出现的次数）
 * <p>
 * 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,
 * 但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。
 */
public class _31_NumberOf1Between1AndN {
    /**
     * 思路1:
     * 1、将数字转换成字符串统计里面 1 的个数
     * -A:
     *
     * @param n
     * @return
     */
    public int NumberOf1Between1AndN_Solution(int n) {
        int count = 0;
        for (int i = 1; i <= n; i++) {
            String string = i + "";
            for (int j = 0; j < string.length(); j++) {
                if (string.charAt(j) == '1') {
                    count++;
                }
            }

        }
        return count;
    }


    /**
     * -- 借鉴网上的思路，这个思路比较巧妙，
     * 方法2：这种类别的题目，如果直观求解不行的话，那么通常是进行找规律，转化成一个数学问题。这道题目在《编程之美》上有着比较详细的描述，下面就结合一个实例进行具体的分析：
     * <p>
     * 在分析之前，首先需要知道一个规律：
     * <p>
     * 从 1 至 10，在它们的个位数中，数字1出现了 1 次。
     * 从 1 至 100，在它们的十位数中，数字1出现了 10 次。
     * 从 1 至 1000，在它们的百位数中，数字1出现了 100 次。
     * 依此类推，从 1 至 10i，在它们右数第二位中，数字1出现了10 ^ (i - 1)次。
     * 对于 n = 2134,要找到从1 ~ 2134这2134个数字中所有1的个数。我们可以对2134进行逐位分析：
     * (1)在个位上，从1~2130，包含213个10，因此数字1出现了213次，剩下的数字2131、2132、2133、2134中个位数上只有2131包含树脂字1，剩下的都不包含。所以个位数上的数字1的总数为213 + 1 = 214。
     * (2)在十位上，从1 ~ 2100，包含了21个100，因此数字1出现了21 * 10 = 210次，剩下的数字从2101 ~ 2134，只有2110 ~ 2119这10个数字中十位的数字为1，所以十位上的数字1的总数为210 + 10 = 220。
     * (3)在百位上，从1 ~ 2000，包含了2个1000，因此数字1出现了2 * 100 = 200次，剩下的数字从2001 ~ 2134，只有2100 ~ 2134这35个数字中的百位的数字为1，所以百位数上数字1的总数为200 + 35= 235。
     * (4)在千位上，包含了0个10000，因此数字1出现了0 * 1000 = 0次，剩下的数字中只有1000 ~ 1999这1000个数字中的千位的数字为1，所以千位上的数字1的总数为1000。
     * 因此从1 ~ 2134这n个数字中，数字出现的总的次数为 214 + 220 + 235 +1000 = 1669。
     * 总结一下以上的步骤，可以得到这么一个规律：
     * 对于数字n，计算它的第i(i从1开始，从右边开始计数)位数上包含的数字1的个数：
     * 假设第i位上的数字为x的话，则
     * 1.如果x > 1的话，则第i位数上包含的1的数目为：(高位数字 + 1）* 10 ^ (i-1) (其中高位数字是从i+1位一直到最高位数构成的数字)
     * 2.如果x < 1的话，则第i位数上包含的1的数目为：(高位数字 ）* 10 ^ (i-1)
     * 3.如果x == 1的话，则第i位数上包含1的数目为：(高位数字) * 10 ^ (i-1) +(低位数字+1) (其中低位数字时从第i - 1位数一直到第1位数构成的数字)
     *
     * @param n
     * @return
     */
    public int NumberOf1Between1AndN_SolutionII(int n) {
        if (n <= 0) {
            return 0;
        }
        int count = 0;//1的个数
        int i = 1;//当前位
        int current = 0, after = 0, before = 0;
        while ((n / i) != 0) {
            current = (n / i) % 10; //高位数字
            before = n / (i * 10); //当前位数字
            after = n - (n / i) * i; //低位数字
            //如果为0,出现1的次数由高位决定,等于高位数字 * 当前位数
            if (current == 0) {
                count += before * i;
            }
            //如果为1,出现1的次数由高位和低位决定,高位*当前位+低位+1
            else if (current == 1) {
                count += before * i + after + 1;
            }
            //如果大于1,出现1的次数由高位决定,//（高位数字+1）* 当前位数
            else {
                count += (before + 1) * i;
            }
            //前移一位
            i = i * 10;
        }
        return count;
    }

    public static void main(String[] args) {
        _31_NumberOf1Between1AndN numberOf1Between1AndN = new _31_NumberOf1Between1AndN();
        System.out.println(numberOf1Between1AndN.NumberOf1Between1AndN_Solution(13));
    }
}
